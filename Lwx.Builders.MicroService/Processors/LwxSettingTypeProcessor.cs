using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Lwx.Builders.MicroService.Processors;

internal class LwxSettingTypeProcessor(
    Generator parent,
    Compilation compilation,
    SourceProductionContext ctx,
    AttributeInstance attr
)
{
    private static readonly HashSet<string> SupportedTypes = new(StringComparer.Ordinal)
    {
        "string",
        "System.String",
        "int",
        "System.Int32",
        "bool",
        "System.Boolean",
        "double",
        "System.Double",
        "long",
        "System.Int64",
        "float",
        "System.Single",
        "decimal",
        "System.Decimal"
    };

    public void Execute()
    {
        if (attr.TargetSymbol is not IPropertySymbol prop)
        {
            return;
        }

        if (!prop.IsStatic)
        {
            ReportError("LWX030", "LwxSetting must be on static property",
                "[LwxSetting] can only be applied to static partial properties. '{0}' is not static.", prop.Name);
            return;
        }

        // Check for partial modifier by examining the syntax
        var isPartial = IsPartialProperty(prop);
        if (!isPartial)
        {
            ReportError("LWX031", "LwxSetting must be on partial property",
                "[LwxSetting] can only be applied to partial properties. '{0}' is not partial.", prop.Name);
            return;
        }

        if (prop.SetMethod != null)
        {
            ReportError("LWX032", "LwxSetting property must be getter-only",
                "[LwxSetting] property '{0}' must be getter-only (no setter allowed).", prop.Name);
            return;
        }

        var typeDisplay = prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var typeSimple = prop.Type.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);

        if (!IsSupportedType(prop.Type))
        {
            ReportError("LWX033", "LwxSetting unsupported type",
                "[LwxSetting] property '{0}' has unsupported type '{1}'. Only primitive types are supported.",
                prop.Name, typeSimple);
            return;
        }

        string? configKey = null;
        if (attr.AttributeData != null)
        {
            var args = attr.AttributeData.ConstructorArguments;
            if (args.Length > 0 && args[0].Value is string key)
            {
                configKey = key;
            }
        }

        if (string.IsNullOrEmpty(configKey))
        {
            ReportError("LWX034", "LwxSetting missing key",
                "[LwxSetting] attribute on property '{0}' requires a non-empty configuration key.", prop.Name);
            return;
        }

        var containingType = prop.ContainingType;
        if (containingType == null)
        {
            return;
        }

        var ns = containingType.ContainingNamespace?.ToDisplayString() ?? "Generated";
        var typeName = containingType.Name;

        var isPartialClass = containingType.DeclaringSyntaxReferences
            .Any(sr => sr.GetSyntax() is TypeDeclarationSyntax tds
                && tds.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)));

        if (!isPartialClass)
        {
            ReportError("LWX035", "LwxSetting containing type must be partial",
                "[LwxSetting] property '{0}' must be declared in a partial class/struct.", prop.Name);
            return;
        }

        var servicePrefix = Generator.ComputeServicePrefix(ns);
        var reg = parent.GetOrCreateRegistration(servicePrefix);

        var settingInfo = new SettingInfo
        {
            ContainingTypeFullName = containingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
            ContainingTypeMinimal = ns + "." + typeName,
            PropertyName = prop.Name,
            PropertyType = typeDisplay,
            ConfigKey = configKey!,
            SequenceNumber = reg.Settings.Count + 1
        };
        reg.Settings.Add(settingInfo);

        var fieldName = "__" + settingInfo.SequenceNumber + "_" + SanitizeForFieldName(configKey!);

        var source = $$"""
// <auto-generated/>
#nullable enable

namespace {{ns}};

partial class {{typeName}}
{
    private static {{typeDisplay}} {{fieldName}} = default!;

    public static partial {{typeDisplay}} {{prop.Name}} => {{fieldName}};
}
""";

        var fileName = "LwxSetting_" + typeName + "_" + prop.Name + ".g.cs";
        ProcessorUtils.AddGeneratedFile(ctx, fileName, source);
    }

    private static bool IsPartialProperty(IPropertySymbol prop)
    {
        // Check if the property declaration has the partial modifier
        foreach (var syntaxRef in prop.DeclaringSyntaxReferences)
        {
            var syntax = syntaxRef.GetSyntax();
            if (syntax is PropertyDeclarationSyntax propSyntax)
            {
                if (propSyntax.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)))
                {
                    return true;
                }
            }
        }
        return false;
    }

    private void ReportError(string id, string title, string message, params object[] args)
    {
        var descriptor = new DiagnosticDescriptor(
            id, title, message, "Configuration", DiagnosticSeverity.Error, isEnabledByDefault: true);
        ctx.ReportDiagnostic(Diagnostic.Create(descriptor, attr.Location, args));
    }

    private static bool IsSupportedType(ITypeSymbol type)
    {
        if (type is INamedTypeSymbol namedType && namedType.IsGenericType)
        {
            var originalDef = namedType.OriginalDefinition.ToDisplayString();
            if (originalDef == "System.Nullable<T>")
            {
                type = namedType.TypeArguments[0];
            }
        }

        var typeStr = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        if (typeStr.StartsWith("global::"))
        {
            typeStr = typeStr.Substring("global::".Length);
        }

        return SupportedTypes.Contains(typeStr)
            || type.SpecialType == SpecialType.System_String
            || type.SpecialType == SpecialType.System_Int32
            || type.SpecialType == SpecialType.System_Boolean
            || type.SpecialType == SpecialType.System_Double
            || type.SpecialType == SpecialType.System_Int64
            || type.SpecialType == SpecialType.System_Single
            || type.SpecialType == SpecialType.System_Decimal;
    }

    private static string SanitizeForFieldName(string key)
    {
        var sb = new StringBuilder(key.Length);
        foreach (var ch in key)
        {
            if (char.IsLetterOrDigit(ch) || ch == '_')
            {
                sb.Append(ch);
            }
            else
            {
                sb.Append('_');
            }
        }
        return sb.ToString();
    }
}

internal class SettingInfo
{
    public string ContainingTypeFullName { get; set; } = string.Empty;
    public string ContainingTypeMinimal { get; set; } = string.Empty;
    public string PropertyName { get; set; } = string.Empty;
    public string PropertyType { get; set; } = string.Empty;
    public string ConfigKey { get; set; } = string.Empty;
    public int SequenceNumber { get; set; }

    public string GetFieldName()
    {
        var sb = new StringBuilder(ConfigKey.Length);
        foreach (var ch in ConfigKey)
        {
            if (char.IsLetterOrDigit(ch) || ch == '_')
            {
                sb.Append(ch);
            }
            else
            {
                sb.Append('_');
            }
        }
        return "__" + SequenceNumber + "_" + sb;
    }
}
