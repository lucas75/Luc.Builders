#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Lwx.Builders.Dto.Processors;
using Lwx.Builders.Dto;

internal enum DtoType
{
    Normal,
    Dictionary
}

namespace Lwx.Builders.Dto.Processors
{
    internal class LwxDtoTypeProcessor
    {
        private FoundAttribute attr;
        private SourceProductionContext ctx;
        private Compilation compilation;
        private DtoGenerator parent;

        public LwxDtoTypeProcessor(DtoGenerator parent, Compilation compilation, SourceProductionContext ctx, FoundAttribute attr)
        {
            this.parent = parent;
            this.attr = attr;
            this.ctx = ctx;
            this.compilation = compilation;
        }

        public void Execute()
        {
            ProcessorUtils.ValidateFilePathMatchesNamespace(attr.TargetSymbol, ctx);

            if (attr.TargetSymbol is not INamedTypeSymbol classSymbol)
            {
                return;
            }

            var dtoType = GetDtoType(attr.AttributeData);
            var ns = classSymbol.ContainingNamespace?.ToDisplayString() ?? "Generated";
            var className = ProcessorUtils.SafeIdentifier(classSymbol.Name);

            var members = GetMembersToProcess(classSymbol, ctx);
            var properties = members.OfType<IPropertySymbol>().ToList();
            var generatedProperties = new List<string>();

            foreach (var prop in properties)
            {
                var propCode = GenerateProperty(prop, dtoType, ctx, compilation);
                if (propCode != null)
                {
                    generatedProperties.Add(propCode);
                }
            }

            if (generatedProperties.Count == 0)
            {
                return;
            }

            var backingFields = dtoType == DtoType.Normal ? GenerateBackingFields(properties) : string.Empty;
            var dictionaryField = dtoType == DtoType.Dictionary ? "private readonly System.Collections.Generic.Dictionary<string, object?> _properties = new();" : string.Empty;

            var source = $$"""
                // <auto-generated/>
                #nullable enable
                using System.Text.Json.Serialization;

                namespace {{ns}};

                public partial class {{className}}
                {
                {{backingFields.FixIndent(1)}}
                {{dictionaryField.FixIndent(1)}}
                {{string.Join("\n\n", generatedProperties).FixIndent(1)}}
                }
                """;

            ProcessorUtils.AddGeneratedFile(ctx, $"LwxDto_{className}.g.cs", source);
        }

        private DtoType GetDtoType(AttributeData? attrData)
        {
            if (attrData == null) return DtoType.Normal;

            var namedMap = attrData.ToNamedArgumentMap();
            if (namedMap.TryGetValue("Type", out var typeArg) && typeArg.Value is int value)
            {
                return (DtoType)value;
            }
            return DtoType.Normal;
        }

        private List<ISymbol> GetMembersToProcess(INamedTypeSymbol classSymbol, SourceProductionContext ctx)
        {
            var members = new List<ISymbol>();
            foreach (var member in classSymbol.GetMembers())
            {
                if (member is IPropertySymbol prop)
                {
                    var hasDtoProp = prop.GetAttributes().Any(a => a.AttributeClass?.Name == "LwxDtoPropertyAttribute");
                    var hasDtoIgnore = prop.GetAttributes().Any(a => a.AttributeClass?.Name == "LwxDtoIgnoreAttribute");
                    if (hasDtoProp || hasDtoIgnore)
                    {
                        if (hasDtoIgnore)
                        {
                            continue;
                        }
                        members.Add(prop);
                    }
                    else
                    {
                        ctx.ReportDiagnostic(Diagnostic.Create(
                            new DiagnosticDescriptor(
                                "LWX005",
                                "DTO property must have [LwxDtoProperty] or [LwxDtoIgnore]",
                                "Property '{0}' in DTO class must be decorated with [LwxDtoProperty] or [LwxDtoIgnore].",
                                "Lwx.Builders.Dto",
                                DiagnosticSeverity.Error,
                                true
                            ),
                            prop.Locations.FirstOrDefault(),
                            prop.Name
                        ));
                    }
                }
                else if (member is IFieldSymbol field && !field.IsImplicitlyDeclared)
                {
                    ctx.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "LWX006",
                            "DTO fields are not allowed",
                            "Field '{0}' in DTO class is not allowed. Use properties instead.",
                            "Lwx.Builders.Dto",
                            DiagnosticSeverity.Error,
                            true
                        ),
                        field.Locations.FirstOrDefault(),
                        field.Name
                    ));
                }
            }
            return members;
        }

        private string GenerateBackingFields(List<IPropertySymbol> properties)
        {
            var fields = new List<string>();
            foreach (var prop in properties)
            {
                var fieldName = $"_{char.ToLower(prop.Name[0])}{prop.Name.Substring(1)}";
                fields.Add($"private {prop.Type.ToDisplayString()} {fieldName};");
            }
            return string.Join("\n", fields);
        }

        private string? GenerateProperty(IPropertySymbol prop, DtoType dtoType, SourceProductionContext ctx, Compilation compilation)
        {
            var propName = prop.Name;
            var propType = prop.Type.ToDisplayString();
            // Consider nullable value types (Nullable<T>) and reference types as nullable
            var isNullable = prop.Type.NullableAnnotation == NullableAnnotation.Annotated || prop.Type.IsReferenceType;
            if (!isNullable && prop.Type is INamedTypeSymbol named && named.IsGenericType)
            {
                // System.Nullable<T>
                var pd = named.ConstructedFrom?.ToDisplayString();
                if (pd == "System.Nullable<T>") isNullable = true;
            }

            var dtoPropAttr = prop.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.Name == "LwxDtoPropertyAttribute");

            string? jsonName = null;
            string? jsonConverterName = null;
            if (dtoPropAttr != null)
            {
                var propArgs = dtoPropAttr.ToNamedArgumentMap();
                if (propArgs.TryGetValue("JsonName", out var jn) && jn.Value is string jns)
                {
                    jsonName = jns;
                }
                // The JsonConverter named argument is a typeof(...) expression; Roslyn represents it as a TypedConstant with Kind == Type
                propArgs.TryGetValue("JsonConverter", out var jsonConvConst);
                if (jsonConvConst.Kind == Microsoft.CodeAnalysis.TypedConstantKind.Type && jsonConvConst.Value is INamedTypeSymbol convSym)
                {
                    // Use the symbol display string so generated source references the converter type by name
                    // Use fully-qualified name (global::...) to avoid ambiguity when emitted in the target namespace
                    jsonConverterName = convSym.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    if (!jsonConverterName.StartsWith("global::", StringComparison.Ordinal))
                    {
                        jsonConverterName = "global::" + jsonConverterName;
                    }
                }
            }

            // Do not emit JsonConverter attributes for built-in date/time types; rely on the runtime's default converters.
            // Keep jsonConverterName null so no JsonConverter attribute is added for DateTimeOffset/DateOnly/TimeOnly.

            var existingJsonProp = prop.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "System.Text.Json.Serialization.JsonPropertyNameAttribute");

            if (existingJsonProp != null && jsonName != null)
            {
                jsonName = null;
            }

            // Warn if using DateTime, recommend DateTimeOffset
            if (prop.Type.ToDisplayString() == "System.DateTime")
            {
                ctx.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor(
                        "LWX007",
                        "Consider using DateTimeOffset instead of DateTime",
                        "Property '{0}' uses DateTime which can be ambiguous due to time zone handling. Consider using DateTimeOffset for better clarity and to avoid potential issues.",
                        "Lwx.Builders.Dto",
                        DiagnosticSeverity.Warning,
                        true
                    ),
                    prop.Locations.FirstOrDefault(),
                    propName
                ));
            }

            if (!IsSupportedType(prop.Type, compilation))
            {
                ctx.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor(
                        "LWX003",
                        "Unsupported DTO property type",
                        "Property '{0}' has an unsupported type. Supported types are primitives, enums, types with [LwxDto], or types with a JsonConverter.",
                        "Lwx.Builders.Dto",
                        DiagnosticSeverity.Error,
                        true
                    ),
                    prop.Locations.FirstOrDefault(),
                    propName
                ));
                return null;
            }

            if (prop.Type.TypeKind == TypeKind.Enum)
            {
                if (prop.Type is INamedTypeSymbol enumType)
                {
                    CheckEnumConstants(enumType, ctx);
                }
            }

            var attributes = new List<string>();

            if (jsonName != null)
            {
                attributes.Add($"[JsonPropertyName(\"{jsonName}\")] " );
            }

            if (isNullable)
            {
                attributes.Add("[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]");
            }

            if (jsonConverterName != null)
            {
                attributes.Add($"[JsonConverter(typeof({jsonConverterName}))]");
            }
            else
            {
                // For enums we want the JsonStringEnumConverter. Also support nullable enum types (Nullable<T> where T is enum).
                if (prop.Type.TypeKind == TypeKind.Enum)
                {
                    attributes.Add("[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]");
                }
                else if (prop.Type is INamedTypeSymbol nn && nn.IsGenericType && nn.ConstructedFrom?.ToDisplayString() == "System.Nullable<T>" && nn.TypeArguments.Length == 1 && nn.TypeArguments[0].TypeKind == TypeKind.Enum)
                {
                    attributes.Add("[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]");
                }
            }
            // (no-op)

            var attrString = attributes.Count > 0 ? string.Join("\n", attributes) + "\n" : "";

            string getterSetter;
            if (dtoType == DtoType.Normal)
            {
                var fieldName = $"_{char.ToLower(propName[0])}{propName.Substring(1)}";
                // Keep inner property indentation at one level (4 spaces). The caller will indent the whole property when embedding.
                getterSetter = $"get => {fieldName};\n    set => {fieldName} = value;";
            }
            else
            {
                var key = jsonName ?? propName;
                getterSetter = $"get => _properties.TryGetValue(\"{key}\", out var value) && value is not null ? ({propType})value : default;\n    set => _properties[\"{key}\"] = value;";
            }
            // Build a property snippet without class-level indentation using a raw interpolated template.
            var propSource = $$"""
                {{attrString}}{{(prop.IsRequired ? "required " : "")}}public partial {{propType}} {{propName}}
                {
                    {{getterSetter}}
                }
                """;
            return propSource;
        }

        private bool IsSupportedType(ITypeSymbol type, Compilation compilation)
        {
            // Handle Nullable<T> by checking its underlying type
            if (type is INamedTypeSymbol named && named.IsGenericType && named.ConstructedFrom?.ToDisplayString() == "System.Nullable<T>")
            {
                return IsSupportedType(named.TypeArguments[0], compilation);
            }
            if (type.SpecialType is
                Microsoft.CodeAnalysis.SpecialType.System_Boolean or
                Microsoft.CodeAnalysis.SpecialType.System_Byte or
                Microsoft.CodeAnalysis.SpecialType.System_SByte or
                Microsoft.CodeAnalysis.SpecialType.System_Int16 or
                Microsoft.CodeAnalysis.SpecialType.System_UInt16 or
                Microsoft.CodeAnalysis.SpecialType.System_Int32 or
                Microsoft.CodeAnalysis.SpecialType.System_UInt32 or
                Microsoft.CodeAnalysis.SpecialType.System_Int64 or
                Microsoft.CodeAnalysis.SpecialType.System_UInt64 or
                Microsoft.CodeAnalysis.SpecialType.System_Single or
                Microsoft.CodeAnalysis.SpecialType.System_Double or
                Microsoft.CodeAnalysis.SpecialType.System_Char or
                Microsoft.CodeAnalysis.SpecialType.System_String) return true;
            if (type.TypeKind == TypeKind.Enum) return true;
            if (type.IsReferenceType && type.GetAttributes().Any(a => a.AttributeClass?.Name == "LwxDtoAttribute")) return true;
            // Support DateTimeOffset, DateOnly, and TimeOnly with default converters
            if (type.ToDisplayString() is "System.DateTimeOffset" or "System.DateOnly" or "System.TimeOnly") return true;
            return false;
        }

        private void CheckEnumConstants(INamedTypeSymbol enumType, SourceProductionContext ctx)
        {
            foreach (var member in enumType.GetMembers().OfType<IFieldSymbol>().Where(f => f.IsConst))
            {
                var hasJsonProp = member.GetAttributes().Any(a => a.AttributeClass?.ToDisplayString() == "System.Text.Json.Serialization.JsonPropertyNameAttribute");
                if (!hasJsonProp)
                {
                    ctx.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "LWX004",
                            "Enum constant missing JsonPropertyName",
                            "Enum constant '{0}' in '{1}' should have [JsonPropertyName] for proper serialization.",
                            "Lwx.Builders.Dto",
                            DiagnosticSeverity.Warning,
                            true
                        ),
                        member.Locations.FirstOrDefault(),
                        member.Name,
                        enumType.Name
                    ));
                }
            }
        }
    }
}
