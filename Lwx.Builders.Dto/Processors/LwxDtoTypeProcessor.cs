#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Lwx.Builders.Dto.Processors;

internal enum DtoType
{
    Normal,
    Dictionary
}

namespace Lwx.Builders.Dto.Processors
{
    internal class LwxDtoTypeProcessor
    {
        private FoundAttribute attr;
        private SourceProductionContext ctx;
        private Compilation compilation;

        public LwxDtoTypeProcessor(FoundAttribute attr, SourceProductionContext ctx, Compilation compilation)
        {
            this.attr = attr;
            this.ctx = ctx;
            this.compilation = compilation;
        }

        public void Execute()
        {
            GeneratorHelpers.ValidateFilePathMatchesNamespace(attr.TargetSymbol, ctx);

            if (attr.TargetSymbol is not INamedTypeSymbol classSymbol)
            {
                return;
            }

            var dtoType = GetDtoType(attr.AttributeData);
            var ns = classSymbol.ContainingNamespace?.ToDisplayString() ?? "Generated";
            var className = GeneratorHelpers.SafeIdentifier(classSymbol.Name);

            var members = GetMembersToProcess(classSymbol, ctx);
            var properties = members.OfType<IPropertySymbol>().ToList();
            var generatedProperties = new List<string>();

            foreach (var prop in properties)
            {
                var propCode = GenerateProperty(prop, dtoType, ctx, compilation);
                if (propCode != null)
                {
                    generatedProperties.Add(propCode);
                }
            }

            if (generatedProperties.Count == 0)
            {
                return;
            }

            var backingFields = dtoType == DtoType.Normal ? GenerateBackingFields(properties) : "";
            var dictionaryField = dtoType == DtoType.Dictionary ? "private readonly System.Collections.Generic.Dictionary<string, object?> _properties = new();" : "";

            var source = "// <auto-generated/>\n" +
                "#nullable enable\n" +
                "using System.Text.Json.Serialization;\n" +
                $"\nnamespace {ns}\n" +
                "{\n" +
                $"    public partial class {className}\n" +
                "    {\n" +
                backingFields + "\n" +
                dictionaryField + "\n" +
                string.Join("\n\n", generatedProperties) + "\n" +
                "    }\n" +
                "}\n"; GeneratorHelpers.AddGeneratedFile(ctx, $"LwxDto_{className}.g.cs", source);
        }

        private DtoType GetDtoType(AttributeData? attrData)
        {
            if (attrData == null) return DtoType.Normal;

            var typeArg = attrData.NamedArguments.FirstOrDefault(kvp => kvp.Key == "Type");
            if (typeArg.Value.Value is int value)
            {
                return (DtoType)value;
            }
            return DtoType.Normal;
        }

        private List<ISymbol> GetMembersToProcess(INamedTypeSymbol classSymbol, SourceProductionContext ctx)
        {
            var members = new List<ISymbol>();
            foreach (var member in classSymbol.GetMembers())
            {
                if (member is IPropertySymbol prop)
                {
                    var hasDtoProp = prop.GetAttributes().Any(a => a.AttributeClass?.Name == "LwxDtoPropertyAttribute");
                    var hasDtoIgnore = prop.GetAttributes().Any(a => a.AttributeClass?.Name == "LwxDtoIgnoreAttribute");
                    if (hasDtoProp || hasDtoIgnore)
                    {
                        if (hasDtoIgnore)
                        {
                            continue;
                        }
                        members.Add(prop);
                    }
                    else
                    {
                        ctx.ReportDiagnostic(Diagnostic.Create(
                            new DiagnosticDescriptor(
                                "LWX005",
                                "DTO property must have [LwxDtoProperty] or [LwxDtoIgnore]",
                                "Property '{0}' in DTO class must be decorated with [LwxDtoProperty] or [LwxDtoIgnore].",
                                "Lwx.Builders.Dto",
                                DiagnosticSeverity.Error,
                                true
                            ),
                            prop.Locations.FirstOrDefault(),
                            prop.Name
                        ));
                    }
                }
                else if (member is IFieldSymbol field && !field.IsImplicitlyDeclared)
                {
                    ctx.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "LWX006",
                            "DTO fields are not allowed",
                            "Field '{0}' in DTO class is not allowed. Use properties instead.",
                            "Lwx.Builders.Dto",
                            DiagnosticSeverity.Error,
                            true
                        ),
                        field.Locations.FirstOrDefault(),
                        field.Name
                    ));
                }
            }
            return members;
        }

        private string GenerateBackingFields(List<IPropertySymbol> properties)
        {
            var fields = new List<string>();
            foreach (var prop in properties)
            {
                var fieldName = $"_{char.ToLower(prop.Name[0])}{prop.Name.Substring(1)}";
                fields.Add($"private {prop.Type.ToDisplayString()} {fieldName};");
            }
            return string.Join("\n", fields);
        }

        private string? GenerateProperty(IPropertySymbol prop, DtoType dtoType, SourceProductionContext ctx, Compilation compilation)
        {
            var propName = prop.Name;
            var propType = prop.Type.ToDisplayString();
            var isNullable = prop.Type.NullableAnnotation == NullableAnnotation.Annotated || prop.Type.IsReferenceType;

            var dtoPropAttr = prop.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.Name == "LwxDtoPropertyAttribute");

            string? jsonName = null;
            string? jsonConverterName = null;
            if (dtoPropAttr != null)
            {
                jsonName = dtoPropAttr.NamedArguments.FirstOrDefault(kvp => kvp.Key == "JsonName").Value.Value as string;
                // The JsonConverter named argument is a typeof(...) expression; Roslyn represents it as a TypedConstant with Kind == Type
                var jsonConvConst = dtoPropAttr.NamedArguments.FirstOrDefault(kvp => kvp.Key == "JsonConverter").Value;
                if (jsonConvConst.Kind == Microsoft.CodeAnalysis.TypedConstantKind.Type && jsonConvConst.Value is INamedTypeSymbol convSym)
                {
                    // Use the symbol display string so generated source references the converter type by name
                    jsonConverterName = convSym.ToDisplayString();
                }
            }

            var existingJsonProp = prop.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "System.Text.Json.Serialization.JsonPropertyNameAttribute");

            if (existingJsonProp != null && jsonName != null)
            {
                jsonName = null;
            }

            if (!IsSupportedType(prop.Type, compilation))
            {
                ctx.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor(
                        "LWX003",
                        "Unsupported DTO property type",
                        "Property '{0}' has an unsupported type. Supported types are primitives, enums, types with [LwxDto], or types with a JsonConverter.",
                        "Lwx.Builders.Dto",
                        DiagnosticSeverity.Error,
                        true
                    ),
                    prop.Locations.FirstOrDefault(),
                    propName
                ));
                return null;
            }

            if (prop.Type.TypeKind == TypeKind.Enum)
            {
                if (prop.Type is INamedTypeSymbol enumType)
                {
                    CheckEnumConstants(enumType, ctx);
                }
            }

            var attributes = new List<string>();

            if (jsonName != null)
            {
                attributes.Add($"[JsonPropertyName(\"{jsonName}\")] " );
            }

            if (isNullable)
            {
                attributes.Add("[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]");
            }

            if (jsonConverterName != null)
            {
                attributes.Add($"[JsonConverter(typeof({jsonConverterName}))]");
            }
            else if (prop.Type.TypeKind == TypeKind.Enum)
            {
                attributes.Add("[JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]");
            }

            var attrString = attributes.Count > 0 ? string.Join("\n", attributes) + "\n" : "";

            string getterSetter;
            if (dtoType == DtoType.Normal)
            {
                var fieldName = $"_{char.ToLower(propName[0])}{propName.Substring(1)}";
                getterSetter = $"get => {fieldName};\n                set => {fieldName} = value;";
            }
            else
            {
                var key = jsonName ?? propName;
                getterSetter = $"get => _properties.TryGetValue(\"{key}\", out var value) && value is not null ? ({propType})value : default;\n                set => _properties[\"{key}\"] = value;";
            }
            return $"{attrString}{(prop.IsRequired ? "required " : "")}public partial {propType} {propName}\n            {{\n                {getterSetter}\n            }}";
        }

        private bool IsSupportedType(ITypeSymbol type, Compilation compilation)
        {
            if (type.SpecialType is
                Microsoft.CodeAnalysis.SpecialType.System_Boolean or
                Microsoft.CodeAnalysis.SpecialType.System_Byte or
                Microsoft.CodeAnalysis.SpecialType.System_SByte or
                Microsoft.CodeAnalysis.SpecialType.System_Int16 or
                Microsoft.CodeAnalysis.SpecialType.System_UInt16 or
                Microsoft.CodeAnalysis.SpecialType.System_Int32 or
                Microsoft.CodeAnalysis.SpecialType.System_UInt32 or
                Microsoft.CodeAnalysis.SpecialType.System_Int64 or
                Microsoft.CodeAnalysis.SpecialType.System_UInt64 or
                Microsoft.CodeAnalysis.SpecialType.System_Single or
                Microsoft.CodeAnalysis.SpecialType.System_Double or
                Microsoft.CodeAnalysis.SpecialType.System_Char or
                Microsoft.CodeAnalysis.SpecialType.System_String) return true;
            if (type.TypeKind == TypeKind.Enum) return true;
            if (type.IsReferenceType && type.GetAttributes().Any(a => a.AttributeClass?.Name == "LwxDtoAttribute")) return true;
            return false;
        }

        private void CheckEnumConstants(INamedTypeSymbol enumType, SourceProductionContext ctx)
        {
            foreach (var member in enumType.GetMembers().OfType<IFieldSymbol>().Where(f => f.IsConst))
            {
                var hasJsonProp = member.GetAttributes().Any(a => a.AttributeClass?.ToDisplayString() == "System.Text.Json.Serialization.JsonPropertyNameAttribute");
                if (!hasJsonProp)
                {
                    ctx.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            "LWX004",
                            "Enum constant missing JsonPropertyName",
                            "Enum constant '{0}' in '{1}' should have [JsonPropertyName] for proper serialization.",
                            "Lwx.Builders.Dto",
                            DiagnosticSeverity.Warning,
                            true
                        ),
                        member.Locations.FirstOrDefault(),
                        member.Name,
                        enumType.Name
                    ));
                }
            }
        }
    }
}
